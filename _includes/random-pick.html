{%- comment -%}
  =========================================================
  INCLUDE : RANDOM PICK (On mange quoi ?)
  Fichier : _includes/random-pick.html

  R√¥le :
  - Affiche une suggestion al√©atoire de recette (hors "gout-sucre")
  - Exclut certains recipe_group du tirage
  - Affiche les badges (tags + micronutriments) de la recette tir√©e

  Options (include.*) :
  - include.hide_links : si true, masque les 2 lignes de liens fixes (tags + micros)

  Mode "page filtr√©e" (auto) :
  - Si document.body.dataset.filterType = "tag"|"micro"
    ET document.body.dataset.filterId = "<id>"
    alors le random pick ne tire que dans les cartes qui matchent ce filtre.

  Ajout :
  - Si document.body.dataset.onlyTested == "true"
    alors le random pick ne tire QUE dans les recettes test√©es.
    (Synchronis√© par _includes/filter-tested.html)

  IMPORTANT (factorisation) :
  - Les 2 lignes de liens fixes (navigation badges) ne sont PLUS √©crites en dur ici.
  - Elles sont rendues via _includes/nav-badges.html (source unique),
    ce qui √©vite les doublons avec index.html / tag-index.html.
  =========================================================
{%- endcomment -%}

<!-- =========================================================
     SUGGESTION AL√âATOIRE
     ========================================================= -->
<div class="mb-4">

  <!-- Zone o√π la ‚Äúpick-card‚Äù est inject√©e par JS -->
  <div id="random-pick"></div>

  {%- comment -%}
    ‚úÖ Bloc ‚Äúnavigation badges‚Äù (HORS tirage)
    - Navigation rapide tags + micronutriments
    - Masquable via include.hide_links pour √©viter les doublons
    - Rendu via nav-badges.html (source unique)
    - On garde badge-link-outside ici pour ton style ‚Äúhors cartes‚Äù
  {%- endcomment -%}
  {%- unless include.hide_links -%}
    {%- include nav-badges.html link_class="badge-link-outside" wrapper_class="random-pick-links mt-2" -%}
  {%- endunless -%}
</div>

<script>
  /*
    =========================================================
    RANDOM PICK
    - Exclut toutes les recettes tagu√©es "gout-sucre"
    - Exclut certains recipe_group du tirage
    - Affiche aussi les badges (tags + micronutriments) de la recette tir√©e
    - Mode page filtr√©e :
        body[data-filter-type="tag|micro"][data-filter-id="..."]
    - Ajout : filtre global "test√©es seulement"
        body[data-only-tested="true"]
      =========================================================
  */

  // On attend que TOUT le DOM soit charg√© (car #recipes-index peut √™tre plus bas).
  document.addEventListener("DOMContentLoaded", () => {

    // Racine : index des recettes (cartes)
    const indexRoot = document.getElementById("recipes-index");

    // Cible : o√π on injecte la ‚Äúpick-card‚Äù
    const pickHost = document.getElementById("random-pick");

    // Si l‚Äôun des √©l√©ments est absent, on ne fait rien (√©vite erreurs console)
    if (!indexRoot || !pickHost) return;

    // ----------------------------
    // MODE "PAGE FILTR√âE" (tags/micros)
    // ----------------------------
    const FILTER_TYPE = (document.body?.dataset?.filterType || "").toLowerCase().trim(); // "tag"|"micro"|"" 
    const FILTER_ID = (document.body?.dataset?.filterId || "").toLowerCase().trim();     // ex: "selenium"

    // ----------------------------
    // FILTRE GLOBAL "TEST√âES SEULEMENT"
    // (pilot√© par _includes/filter-tested.html)
    // ----------------------------
    function isOnlyTestedActive() {
      return (document.body?.dataset?.onlyTested || "").toLowerCase().trim() === "true";
    }

    // Tag exclu du tirage
    const EXCLUDED_TAG = "gout-sucre";

    // Tags cach√©s (utiles c√¥t√© data, mais pas affich√©s comme badges ‚Äúfonctionnels‚Äù)
    const HIDDEN_TAGS = new Set(["low-carb-modere", "low-carb-strict", "gout-sucre"]);

    /*
      Exclusions du tirage al√©atoire par recipe_group (comparaison en minuscules).
      IMPORTANT : data-recipe-group contient le nom humain (ex: "Plats √† base de viande")
      => on compare en minuscules ici.
    */
    const EXCLUDED_GROUPS = [
      "amuse-bouche",
      "boissons",
      "pains & substituts",
      "p√¢tes & fonds",
      "sauces & assaisonnements",
      "l√©gumes & accompagnements",
      "pr√©parations & conservations",
      "barres nutritionnelles"
    ];

    // Mapping tag -> { emoji, title }
    const TAG_BADGES = {
      "tres-proteine":   { emoji: "üí™", title: "Tr√®s prot√©in√©" },
      "riche-en-fibres": { emoji: "üí©", title: "Riche en fibres" },
      "rapide":          { emoji: "‚è±Ô∏è", title: "Rapide" },
      "congelable":      { emoji: "‚ùÑÔ∏è", title: "Cong√©lable" },
      "micro-ondable":   { emoji: "‚ô®Ô∏è", title: "Micro-ondable" },
      "peu-calorique":   { emoji: "ü™∂", title: "Peu calorique" },
      "calorique":       { emoji: "üî•", title: "Calorique" },
      "longue":          { emoji: "üêå", title: "Pr√©paration longue" }
    };

    // Mapping micronutriment -> { emoji, title }
    const MICRO_BADGES = {
      "omega-3":      { emoji: "üêü", title: "Om√©ga-3" },

      "vitamine-a":   { emoji: "üëÅÔ∏è", title: "Vitamine A" },
      "vitamine-c":   { emoji: "üçã", title: "Vitamine C" },
      "vitamine-d":   { emoji: "üå§Ô∏è", title: "Vitamine D" },
      "vitamine-e":   { emoji: "üõ°Ô∏è", title: "Vitamine E" },
      "vitamine-k":   { emoji: "ü©∏", title: "Vitamine K" },
      "vitamine-b9":  { emoji: "üå±", title: "Vitamine B9" },
      "vitamine-b12": { emoji: "ü•©", title: "Vitamine B12" },

      "calcium":      { emoji: "ü¶¥", title: "Calcium" },
      "fer":          { emoji: "üß≤", title: "Fer" },
      "magnesium":    { emoji: "‚ö°", title: "Magn√©sium" },
      "potassium":    { emoji: "üçå", title: "Potassium" },
      "zinc":         { emoji: "üî©", title: "Zinc" },
      "selenium":     { emoji: "üß™", title: "S√©l√©nium" },
      "iode":         { emoji: "üåä", title: "Iode" }
    };

    // Pour √©viter de retomber sur la m√™me recette trop souvent
    let lastHref = null;

    // Convertit "a,b,c" -> ["a","b","c"] en minuscules
    function parseList(str) {
      return (str || "")
        .split(",")
        .map(s => s.trim().toLowerCase())
        .filter(Boolean);
    }

    // V√©rifie si le lien correspond √† une recette exploitable
    function isValidRecipeLink(a) {
      const href = (a.getAttribute("href") || "").trim();
      if (!href) return false;

      // On ignore les ancres
      if (href.startsWith("#")) return false;

      const title = (a.dataset.title || a.textContent || "").trim();
      if (!title) return false;

      return true;
    }

    // Exclut les cartes tagu√©es "gout-sucre"
    function hasExcludedTag(card) {
      const tags = parseList(card?.dataset?.tags);
      return tags.includes(EXCLUDED_TAG);
    }

    // Exclut certains recipe_group
    function isInExcludedGroup(a) {
      const groupEl = a.closest("[data-recipe-group]");
      if (!groupEl) return false;

      const group = (groupEl.dataset.recipeGroup || "").toLowerCase().trim();
      return EXCLUDED_GROUPS.includes(group);
    }

    // V√©rifie que la carte correspond au filtre courant (si pr√©sent)
    function matchesPageFilter(card) {
      // Pas de filtre => tout passe
      if (!FILTER_TYPE || !FILTER_ID) return true;

      if (FILTER_TYPE === "tag") {
        const tags = parseList(card?.dataset?.tags);
        return tags.includes(FILTER_ID);
      }

      if (FILTER_TYPE === "micro") {
        const micros = parseList(card?.dataset?.micros);
        return micros.includes(FILTER_ID);
      }

      // Type inconnu => on ne filtre pas (s√©curit√©)
      return true;
    }

    // Filtre global : si "test√©es seulement" est actif, on ne garde que data-tested="true"
    function matchesOnlyTested(a) {
      if (!isOnlyTestedActive()) return true;
      return (a.dataset.tested || "").toLowerCase().trim() === "true";
    }

    // Liste des candidats au tirage
    function getCandidates() {
      return Array.from(indexRoot.querySelectorAll(".recipe-card a[href]"))
        .filter(isValidRecipeLink)
        .filter(a => {
          const card = a.closest(".recipe-card");
          if (!card) return false;

          // Exclusions globales
          if (hasExcludedTag(card)) return false;
          if (isInExcludedGroup(a)) return false;

          // Filtre de page (tags/micros)
          if (!matchesPageFilter(card)) return false;

          // Filtre global (test√©es seulement)
          if (!matchesOnlyTested(a)) return false;

          return true;
        });
    }

    // Tirage al√©atoire (√©vite de r√©p√©ter la m√™me recette)
    function pickRandom(links) {
      if (!links.length) return null;

      let a, tries = 0;
      do {
        a = links[Math.floor(Math.random() * links.length)];
        tries++;
      } while (a.getAttribute("href") === lastHref && tries < 20);

      lastHref = a.getAttribute("href");
      return a;
    }

    // Construit une ligne de badges (UL) √† partir d‚Äôune liste d‚ÄôIDs et d‚Äôun mapping
    function buildBadgeLine(items, map, ariaLabel) {
      const lis = items
        .map(id => {
          const info = map[id];
          if (!info) return "";
          const title = (info.title || "").replace(/"/g, "&quot;");
          return `<li title="${title}">${info.emoji}</li>`;
        })
        .filter(Boolean)
        .join("");

      if (!lis) return "";
      return `<ul class="recipe-badges-line" aria-label="${ariaLabel}">${lis}</ul>`;
    }

    // Badges √† afficher dans le random pick pour UNE recette
    function buildPickBadges(card) {
      const tagsAll = parseList(card?.dataset?.tags);

      // Tags fonctionnels : on enl√®ve les tags cach√©s + on garde seulement ceux connus
      const tagsFunctional = tagsAll.filter(t => !HIDDEN_TAGS.has(t) && TAG_BADGES[t]);

      const microsAll = parseList(card?.dataset?.micros);
      const micros = microsAll.filter(m => MICRO_BADGES[m]);

      const line1 = buildBadgeLine(tagsFunctional, TAG_BADGES, "Badges");
      const line2 = buildBadgeLine(micros, MICRO_BADGES, "Micronutriments");

      if (!line1 && !line2) return "";
      return `
        <div class="recipe-badges-wrap">
          ${line1}
          ${line2}
        </div>
      `;
    }

    // Affiche la carte ‚ÄúOn mange quoi ?‚Äù
    function renderPick(a) {
      const title = (a.dataset.title || a.textContent || "").trim();
      const subtitle = (a.dataset.subtitle || "").trim();
      const tested = a.dataset.tested === "true";
      const href = a.getAttribute("href");

      const card = a.closest(".recipe-card");
      const badgesHtml = buildPickBadges(card);

      pickHost.innerHTML = `
        <div class="pick-card">
          <div class="pick-card-body text-center">
            <div class="mb-2 fw-bold fs-4">On mange quoi&nbsp;?</div>

            <h3 class="h5 mb-1">
              ${title}
              ${tested ? "" : `
                <span class="badge bg-warning text-dark ms-2">
                  Recette non test√©e
                </span>
              `}
            </h3>

            ${subtitle ? `<div class="recipe-card-subtitle mb-2">${subtitle}</div>` : ""}

            ${badgesHtml}

            <div class="d-flex justify-content-center gap-2 mt-3">
              <a class="btn btn-primary" href="${href}">√áa me pla√Æt</a>
              <button id="btn-reroll" type="button" class="btn btn-outline-secondary">
                Autre id√©e
              </button>
            </div>
          </div>
        </div>
      `;

      // Bouton ‚ÄúAutre id√©e‚Äù : relance un tirage
      document.getElementById("btn-reroll").onclick = pickAndRender;
    }

    /*
      - Si aucun candidat n‚Äôexiste, on n‚Äôaffiche RIEN.
      - On vide juste la zone #random-pick et on sort.
    */
    function pickAndRender() {
      const links = getCandidates();

      if (!links.length) {
        pickHost.innerHTML = "";
        return;
      }

      const a = pickRandom(links);

      if (!a) {
        pickHost.innerHTML = "";
        return;
      }

      renderPick(a);
    }

    // Lancement initial
    pickAndRender();

    // R√©agit au changement du filtre "test√©es seulement"
    document.addEventListener("testedFilterChanged", function () {
      pickAndRender();
    });
  });
</script>

