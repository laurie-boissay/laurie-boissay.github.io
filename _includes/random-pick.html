{%- comment -%}
  =========================================================
  INCLUDE : RANDOM PICK (On mange quoi ?)
  Fichier : _includes/random-pick.html

  Rôle :
  - Affiche une suggestion aléatoire de recette (hors "gout-sucre")
  - Exclut certains recipe_group du tirage
  - Affiche les badges (tags + micronutriments) de la recette tirée

  Options (include.*) :
  - include.hide_links : si true, masque les 2 lignes de liens fixes (tags + micros)

  Mode "page filtrée" (auto) :
  - Si document.body.dataset.filterType = "tag"|"micro"
    ET document.body.dataset.filterId = "<id>"
    alors le random pick ne tire que dans les cartes qui matchent ce filtre.

  Ajout :
  - Si document.body.dataset.onlyTested == "true"
    alors le random pick ne tire QUE dans les recettes testées.
    (Synchronisé par _includes/filter-tested.html)

  IMPORTANT (factorisation) :
  - Les 2 lignes de liens fixes (navigation badges) ne sont PLUS écrites en dur ici.
  - Elles sont rendues via _includes/nav-badges.html (source unique),
    ce qui évite les doublons avec index.html / tag-index.html.

  IMPORTANT (factorisation JS) :
  - Les mappings TAG_BADGES / MICRO_BADGES ne sont PLUS définis ici.
  - Ils viennent de assets/js/badges-map.js chargé dans le <head>.
  =========================================================
{%- endcomment -%}

<!-- =========================================================
     SUGGESTION ALÉATOIRE
     ========================================================= -->
<div class="mb-4">

  <!-- Zone où la “pick-card” est injectée par JS -->
  <div id="random-pick"></div>

  {%- comment -%}
    ✅ Bloc “navigation badges” (HORS tirage)
    - Navigation rapide tags + micronutriments
    - Masquable via include.hide_links pour éviter les doublons
    - Rendu via nav-badges.html (source unique)
    - On garde badge-link-outside ici pour ton style “hors cartes”
  {%- endcomment -%}
  {%- unless include.hide_links -%}
    {%- include nav-badges.html link_class="badge-link-outside" wrapper_class="random-pick-links mt-2" -%}
  {%- endunless -%}
</div>

<script>
  /*
    =========================================================
    RANDOM PICK
    - Exclut toutes les recettes taguées "gout-sucre"
    - Exclut certains recipe_group du tirage
    - Affiche aussi les badges (tags + micronutriments) de la recette tirée
    - Mode page filtrée :
        body[data-filter-type="tag|micro"][data-filter-id="..."]
    - Ajout : filtre global "testées seulement"
        body[data-only-tested="true"]
      =========================================================
  */

  // On attend que TOUT le DOM soit chargé (car #recipes-index peut être plus bas).
  document.addEventListener("DOMContentLoaded", () => {

    // Racine : index des recettes (cartes)
    const indexRoot = document.getElementById("recipes-index");

    // Cible : où on injecte la “pick-card”
    const pickHost = document.getElementById("random-pick");

    // Si l’un des éléments est absent, on ne fait rien (évite erreurs console)
    if (!indexRoot || !pickHost) return;

    // ----------------------------
    // MODE "PAGE FILTRÉE" (tags/micros)
    // ----------------------------
    const FILTER_TYPE = (document.body?.dataset?.filterType || "").toLowerCase().trim(); // "tag"|"micro"|"" 
    const FILTER_ID = (document.body?.dataset?.filterId || "").toLowerCase().trim();     // ex: "selenium"

    // ----------------------------
    // FILTRE GLOBAL "TESTÉES SEULEMENT"
    // (piloté par _includes/filter-tested.html)
    // ----------------------------
    function isOnlyTestedActive() {
      return (document.body?.dataset?.onlyTested || "").toLowerCase().trim() === "true";
    }

    // Tag exclu du tirage
    const EXCLUDED_TAG = "gout-sucre";

    // Tags cachés (utiles côté data, mais pas affichés comme badges “fonctionnels”)
    const HIDDEN_TAGS = new Set(["low-carb-modere", "low-carb-strict", "gout-sucre"]);

    /*
      Exclusions du tirage aléatoire par recipe_group (comparaison en minuscules).
      IMPORTANT : data-recipe-group contient le nom humain (ex: "Plats à base de viande")
      => on compare en minuscules ici.
    */
    const EXCLUDED_GROUPS = [
      "amuse-bouche",
      "boissons",
      "pains & substituts",
      "pâtes & fonds",
      "sauces & assaisonnements",
      "légumes & accompagnements",
      "préparations & conservations",
      "barres nutritionnelles"
    ];

    // =========================================================
    // MAPPINGS BADGES (centralisés)
    // - Définis dans assets/js/badges-map.js (chargé dans le <head>)
    // - Fallback safe si le fichier n'est pas chargé / erreur 404
    // =========================================================
    const BADGES_MAP = window.RECETTES_BADGES_MAP || { TAG_BADGES: {}, MICRO_BADGES: {} };
    const TAG_BADGES = BADGES_MAP.TAG_BADGES || {};
    const MICRO_BADGES = BADGES_MAP.MICRO_BADGES || {};

    // Pour éviter de retomber sur la même recette trop souvent
    let lastHref = null;

    // Convertit "a,b,c" -> ["a","b","c"] en minuscules
    function parseList(str) {
      return (str || "")
        .split(",")
        .map(s => s.trim().toLowerCase())
        .filter(Boolean);
    }

    // Vérifie si le lien correspond à une recette exploitable
    function isValidRecipeLink(a) {
      const href = (a.getAttribute("href") || "").trim();
      if (!href) return false;

      // On ignore les ancres
      if (href.startsWith("#")) return false;

      const title = (a.dataset.title || a.textContent || "").trim();
      if (!title) return false;

      return true;
    }

    // Exclut les cartes taguées "gout-sucre"
    function hasExcludedTag(card) {
      const tags = parseList(card?.dataset?.tags);
      return tags.includes(EXCLUDED_TAG);
    }

    // Exclut certains recipe_group
    function isInExcludedGroup(a) {
      const groupEl = a.closest("[data-recipe-group]");
      if (!groupEl) return false;

      const group = (groupEl.dataset.recipeGroup || "").toLowerCase().trim();
      return EXCLUDED_GROUPS.includes(group);
    }

    // Vérifie que la carte correspond au filtre courant (si présent)
    function matchesPageFilter(card) {
      // Pas de filtre => tout passe
      if (!FILTER_TYPE || !FILTER_ID) return true;

      if (FILTER_TYPE === "tag") {
        const tags = parseList(card?.dataset?.tags);
        return tags.includes(FILTER_ID);
      }

      if (FILTER_TYPE === "micro") {
        const micros = parseList(card?.dataset?.micros);
        return micros.includes(FILTER_ID);
      }

      // Type inconnu => on ne filtre pas (sécurité)
      return true;
    }

    // Filtre global : si "testées seulement" est actif, on ne garde que data-tested="true"
    function matchesOnlyTested(a) {
      if (!isOnlyTestedActive()) return true;
      return (a.dataset.tested || "").toLowerCase().trim() === "true";
    }

    // Liste des candidats au tirage
    function getCandidates() {
      return Array.from(indexRoot.querySelectorAll(".recipe-card a[href]"))
        .filter(isValidRecipeLink)
        .filter(a => {
          const card = a.closest(".recipe-card");
          if (!card) return false;

          // Exclusions globales
          if (hasExcludedTag(card)) return false;
          if (isInExcludedGroup(a)) return false;

          // Filtre de page (tags/micros)
          if (!matchesPageFilter(card)) return false;

          // Filtre global (testées seulement)
          if (!matchesOnlyTested(a)) return false;

          return true;
        });
    }

    // Tirage aléatoire (évite de répéter la même recette)
    function pickRandom(links) {
      if (!links.length) return null;

      let a, tries = 0;
      do {
        a = links[Math.floor(Math.random() * links.length)];
        tries++;
      } while (a.getAttribute("href") === lastHref && tries < 20);

      lastHref = a.getAttribute("href");
      return a;
    }

    // Construit une ligne de badges (UL) à partir d’une liste d’IDs et d’un mapping
    function buildBadgeLine(items, map, ariaLabel) {
      const lis = items
        .map(id => {
          const info = map[id];
          if (!info) return "";
          const title = (info.title || "").replace(/"/g, "&quot;");
          return `<li title="${title}">${info.emoji}</li>`;
        })
        .filter(Boolean)
        .join("");

      if (!lis) return "";
      return `<ul class="recipe-badges-line" aria-label="${ariaLabel}">${lis}</ul>`;
    }

    // Badges à afficher dans le random pick pour UNE recette
    function buildPickBadges(card) {
      const tagsAll = parseList(card?.dataset?.tags);

      // Tags fonctionnels : on enlève les tags cachés + on garde seulement ceux connus
      const tagsFunctional = tagsAll.filter(t => !HIDDEN_TAGS.has(t) && TAG_BADGES[t]);

      const microsAll = parseList(card?.dataset?.micros);
      const micros = microsAll.filter(m => MICRO_BADGES[m]);

      const line1 = buildBadgeLine(tagsFunctional, TAG_BADGES, "Badges");
      const line2 = buildBadgeLine(micros, MICRO_BADGES, "Micronutriments");

      if (!line1 && !line2) return "";
      return `
        <div class="recipe-badges-wrap">
          ${line1}
          ${line2}
        </div>
      `;
    }

    // Affiche la carte “On mange quoi ?”
    function renderPick(a) {
      const title = (a.dataset.title || a.textContent || "").trim();
      const subtitle = (a.dataset.subtitle || "").trim();
      const tested = a.dataset.tested === "true";
      const href = a.getAttribute("href");

      const card = a.closest(".recipe-card");
      const badgesHtml = buildPickBadges(card);

      pickHost.innerHTML = `
        <div class="pick-card">
          <div class="pick-card-body text-center">
            <div class="mb-2 fw-bold fs-4">On mange quoi&nbsp;?</div>

            <h3 class="h5 mb-1">
              ${title}
              ${tested ? "" : `
                <span class="badge bg-warning text-dark ms-2">
                  Recette non testée
                </span>
              `}
            </h3>

            ${subtitle ? `<div class="recipe-card-subtitle mb-2">${subtitle}</div>` : ""}

            ${badgesHtml}

            <div class="d-flex justify-content-center gap-2 mt-3">
              <a class="btn btn-primary" href="${href}">Ça me plaît</a>
              <button id="btn-reroll" type="button" class="btn btn-outline-secondary">
                Autre idée
              </button>
            </div>
          </div>
        </div>
      `;

      // Bouton “Autre idée” : relance un tirage
      document.getElementById("btn-reroll").onclick = pickAndRender;
    }

    /*
      - Si aucun candidat n’existe, on n’affiche RIEN.
      - On vide juste la zone #random-pick et on sort.
    */
    function pickAndRender() {
      const links = getCandidates();

      if (!links.length) {
        pickHost.innerHTML = "";
        return;
      }

      const a = pickRandom(links);

      if (!a) {
        pickHost.innerHTML = "";
        return;
      }

      renderPick(a);
    }

    // Lancement initial
    pickAndRender();

    // Réagit au changement du filtre "testées seulement"
    document.addEventListener("testedFilterChanged", function () {
      pickAndRender();
    });
  });
</script>

