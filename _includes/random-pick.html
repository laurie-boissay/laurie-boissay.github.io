{%- comment -%}
==============================================================================
_includes/random-pick.html — “On mange quoi ?” (suggestion aléatoire)
==============================================================================

Évolutions UX :
- Le titre de la recette dans la pick-card est désormais cliquable.
- Les badges (tags fonctionnels + micronutriments) sont cliquables.
- Cohérent avec la structure “carte non cliquable + lien sur le titre”.
- Exclusion de certains recipe_group non tirables (bases, boissons, etc.).

Ajustements UI (stabilité) :
- Placeholders pour sous-titre et badges : la hauteur de la carte ne varie plus.
- Zone boutons poussée en bas via flex (CSS), même si contenu variable.
==============================================================================
{%- endcomment -%}

<div class="mb-4">
  <div id="random-pick"></div>

  {%- unless include.hide_links -%}
    {%- include nav-badges.html link_class="badge-link-outside" wrapper_class="random-pick-links mt-2" -%}
  {%- endunless -%}
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {

  const indexRoot = document.getElementById("recipes-index");
  const pickHost  = document.getElementById("random-pick");
  if (!indexRoot || !pickHost) return;

  const FILTER_TYPE = (document.body?.dataset?.filterType || "").toLowerCase().trim();
  const FILTER_ID   = (document.body?.dataset?.filterId   || "").toLowerCase().trim();

  function isOnlyTestedActive() {
    return (document.body?.dataset?.onlyTested || "").toLowerCase().trim() === "true";
  }

  const EXCLUDED_TAG = "gout-sucre";

  const HIDDEN_TAGS = new Set([
    "low-carb-modere",
    "low-carb-strict",
    "gout-sucre"
  ]);

  /*
    Groupes exclus du tirage aléatoire.
    Contrat :
    - Ne pas tirer les bases (pains, sauces, préparations...), boissons, etc.
    - Ne pas tirer "Fromages" (fiches unitaires, non destinées au menu).
    Note : la comparaison est faite en minuscules (toLowerCase()).
  */
  const EXCLUDED_GROUPS = [
    "amuse-bouche",
    "aliments simples",
    "boissons",
    "fromages",
    "pains & substituts",
    "pâtes & fonds",
    "sauces & assaisonnements",
    "légumes & accompagnements",
    "préparations & conservations",
    "barres nutritionnelles"
  ];

  const BADGES_MAP   = window.RECETTES_BADGES_MAP || { TAG_BADGES: {}, MICRO_BADGES: {} };
  const TAG_BADGES   = BADGES_MAP.TAG_BADGES   || {};
  const MICRO_BADGES = BADGES_MAP.MICRO_BADGES || {};

  let lastHref = null;

  function parseList(str) {
    return (str || "")
      .split(",")
      .map(s => s.trim().toLowerCase())
      .filter(Boolean);
  }

  function getTitleLink(card){
    return card?.querySelector("a.recipe-title-link[href]") || null;
  }

  function getRecipeHref(card){
    return getTitleLink(card)?.getAttribute("href")?.trim() || "";
  }

  function getRecipeTitle(card){
    return getTitleLink(card)?.textContent?.trim() || "";
  }

  function getRecipeSubtitle(card){
    return card?.querySelector(".recipe-card-subtitle")?.textContent?.trim() || "";
  }

  function isRecipeTested(card){
    const item = card?.closest(".recipe-item");
    return (item?.dataset?.tested || "").toLowerCase() === "true";
  }

  function hasExcludedTag(card){
    return parseList(card?.dataset?.tags).includes(EXCLUDED_TAG);
  }

  function isInExcludedGroup(card){
    const group = card?.closest("[data-recipe-group]")?.dataset?.recipeGroup?.toLowerCase().trim();
    return EXCLUDED_GROUPS.includes(group);
  }

  function matchesPageFilter(card){
    if (!FILTER_TYPE || !FILTER_ID) return true;

    if (FILTER_TYPE === "tag"){
      return parseList(card?.dataset?.tags).includes(FILTER_ID);
    }

    if (FILTER_TYPE === "micro"){
      return parseList(card?.dataset?.micros).includes(FILTER_ID);
    }

    return true;
  }

  function matchesOnlyTested(card){
    if (!isOnlyTestedActive()) return true;
    return isRecipeTested(card);
  }

  function isValidCard(card){
    return getRecipeHref(card) && getRecipeTitle(card);
  }

  function getCandidates(){
    return Array.from(indexRoot.querySelectorAll(".recipe-card"))
      .filter(isValidCard)
      .filter(card =>
        !hasExcludedTag(card) &&
        !isInExcludedGroup(card) &&
        matchesPageFilter(card) &&
        matchesOnlyTested(card)
      );
  }

  function pickRandom(cards){
    if (!cards.length) return null;

    let card;
    let tries = 0;
    do{
      card = cards[Math.floor(Math.random() * cards.length)];
      tries++;
    }while(getRecipeHref(card) === lastHref && tries < 20);

    lastHref = getRecipeHref(card);
    return card;
  }

  /* ===============================
     BADGES CLIQUABLES
     =============================== */

  function buildBadgeLine(items, map, ariaLabel, type){
    const lis = items.map(id => {
      const info = map[id];
      if (!info) return "";

      const url = type === "tag"
        ? `/tags/${id}/`
        : `/micronutriments/${id}/`;

      return `
        <li>
          <a class="badge-link-outside" href="${url}" title="${info.title}">
            ${info.emoji}
          </a>
        </li>
      `;
    }).join("");

    if (!lis) return "";
    return `<ul class="recipe-badges-line" aria-label="${ariaLabel}">${lis}</ul>`;
  }

  function buildPickBadges(card){
    const tagsAll = parseList(card?.dataset?.tags);
    const tagsFunctional = tagsAll.filter(t => !HIDDEN_TAGS.has(t) && TAG_BADGES[t]);

    const microsAll = parseList(card?.dataset?.micros);
    const micros = microsAll.filter(m => MICRO_BADGES[m]);

    const line1 = buildBadgeLine(tagsFunctional, TAG_BADGES, "Tags fonctionnels", "tag");
    const line2 = buildBadgeLine(micros, MICRO_BADGES, "Micronutriments", "micro");

    if (!line1 && !line2) return "";

    return `
      <div class="recipe-badges-wrap">
        ${line1}
        ${line2}
      </div>
    `;
  }

  function renderPick(card){

    const title    = getRecipeTitle(card);
    const subtitle = getRecipeSubtitle(card);
    const tested   = isRecipeTested(card);
    const href     = getRecipeHref(card);

    /* Placeholders :
       - subtitle absent => on garde une ligne vide (hauteur stable)
       - badges absents => on garde un bloc vide (hauteur stable) */
    const subtitleHtml = subtitle
      ? `<div class="recipe-card-subtitle mb-2">${subtitle}</div>`
      : `<div class="recipe-card-subtitle mb-2 is-empty" aria-hidden="true"></div>`;

    const badgesHtml = buildPickBadges(card) || `
      <div class="recipe-badges-wrap is-empty" aria-hidden="true">
        <ul class="recipe-badges-line is-empty" aria-hidden="true"></ul>
      </div>
    `;

    pickHost.innerHTML = `
      <div class="pick-card">
        <div class="pick-card-body text-center">
          <div class="mb-2 fw-bold fs-4">On mange quoi&nbsp;?</div>

          <h3 class="h5 mb-1">
            <a class="recipe-title-link" href="${href}">
              ${title}
            </a>
            ${tested ? "" : `
              <span class="badge bg-warning text-dark ms-2">
                Recette non testée
              </span>
            `}
          </h3>

          ${subtitleHtml}

          ${badgesHtml}

          <div class="d-flex justify-content-center gap-2 mt-3">
            <a class="btn btn-primary" href="${href}">Ça me plaît</a>
            <button id="btn-reroll" type="button" class="btn btn-outline-secondary">
              Autre idée
            </button>
          </div>
        </div>
      </div>
    `;

    document.getElementById("btn-reroll").onclick = pickAndRender;
  }

  function pickAndRender(){
    const cards = getCandidates();
    if (!cards.length){
      pickHost.innerHTML = "";
      return;
    }

    const card = pickRandom(cards);
    if (!card){
      pickHost.innerHTML = "";
      return;
    }

    renderPick(card);
  }

  pickAndRender();

  document.addEventListener("testedFilterChanged", pickAndRender);
});
</script>
